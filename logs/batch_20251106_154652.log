/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
üöÄ Starting batch prediction job: batch_20251106_154652
   Total races: 821
   Workers: 3
   Chunk size: 50
   Memory limit: 4096.0MB
   Database: 2years

‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
[5%] Loading races from database...
[15%] Loaded 821 races, starting predictions...
[20%] Processing chunk 1/17 (Mem: 813MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 15:47:07,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,023 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:07,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,023 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:07,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,029 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,030 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:07,030 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:07,033 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:47:30,231 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,231 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:30,231 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,232 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,232 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:30,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,234 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,235 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,235 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:30,235 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,235 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:30,239 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:47:43,658 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,659 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:43,659 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,661 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,667 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,668 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:43,668 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,669 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,669 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:43,669 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,670 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:43,672 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:47:56,637 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,638 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:56,638 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,640 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,641 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,641 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:56,641 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,643 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,646 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,646 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:47:56,646 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:47:56,649 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:48:09,484 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,485 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:09,485 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,485 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,485 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:09,485 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,487 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,487 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,489 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,489 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:09,489 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:09,491 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:48:22,320 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,321 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:22,321 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,329 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,329 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:22,329 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,332 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,334 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,334 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:22,334 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:22,336 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:48:34,936 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,936 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:34,936 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,936 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,937 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:34,937 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,939 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,939 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,942 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,942 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:34,942 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:34,945 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:48:47,530 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,531 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:47,531 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,532 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,532 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:47,532 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,533 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,534 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,534 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,535 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:47,535 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:47,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:48:59,901 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,901 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:59,901 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,903 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,903 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:59,903 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,904 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,905 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,906 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:48:59,906 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,906 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:48:59,909 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:49:14,362 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,362 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:49:14,363 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,364 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:49:14,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,365 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:49:14,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,367 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:49:14,368 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:55:32,775 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,776 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:55:32,776 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,778 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,783 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,784 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:55:32,784 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,785 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,786 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:55:32,786 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,787 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:32,789 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:55:56,331 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,332 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:55:56,332 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,334 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,343 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:55:56,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,343 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:55:56,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,346 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:55:56,346 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:56:11,431 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,432 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:11,432 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,433 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,433 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:11,433 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,434 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,434 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,435 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:11,435 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,436 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:11,437 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:56:28,451 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,451 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:28,451 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,451 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,452 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:28,452 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,454 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,454 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,458 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,458 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:28,458 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:28,461 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:56:48,757 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,758 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:48,758 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,758 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,758 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:48,758 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,761 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,761 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,762 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,762 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:56:48,762 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:56:48,765 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 109,143 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 109,143 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 165,583 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 165,583 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 72,583 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 72,583 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 215,333 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 215,333 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 108,846 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 108,846 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 189,840 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 189,840 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 239,657 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 239,657 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 218,086 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 218,086 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 136,697 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 136,697 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 121,816 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 121,816 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T13:43:19.817248
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 166,115 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 166,115 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:49.614306
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 98,194 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 98,194 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 166,693 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 166,693 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 151,250 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 151,250 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 111,730 (from 14 horses)
  üìä Processing 14 horses for feature calculation...2025-11-06 15:57:10,711 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:10,711 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:57:10,711 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:10,714 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:57:24,430 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:24,431 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:57:24,431 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:24,433 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:57:37,403 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:37,403 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:57:37,403 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:37,405 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:57:50,745 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:50,746 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:57:50,747 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:57:50,749 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:58:03,558 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:03,559 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:03,559 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:03,562 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 111,730 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 172,957 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 172,957 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 227,442 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 227,442 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[24%] Processing chunk 2/17 (Mem: 412MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 15:58:23,823 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,824 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:23,824 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,826 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:23,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,828 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,828 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:23,828 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,829 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:23,831 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:58:42,621 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,622 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:42,622 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,624 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,627 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,627 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:42,627 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,629 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,634 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,634 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:58:42,634 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:58:42,637 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:59:20,061 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,062 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:20,062 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,062 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,063 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:20,063 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,064 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,065 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,075 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,075 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:20,076 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:20,079 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:59:34,362 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,362 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:34,363 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,366 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,366 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:34,366 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,369 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,370 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,371 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:34,371 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:34,373 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 15:59:47,698 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,699 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:47,699 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,700 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,700 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:47,700 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,701 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,702 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,707 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,708 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 15:59:47,708 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 15:59:47,711 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:00:00,640 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,640 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:00,640 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,642 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,648 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,649 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:00,649 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,649 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,649 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:00:00,649 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,650 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:00,651 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:00:13,614 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,614 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:00:13,615 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,616 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,618 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,618 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:13,618 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,619 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,619 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:13,619 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,620 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:13,622 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:00:26,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,527 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:00:26,527 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:26,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,529 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,529 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,534 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,535 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:26,535 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:26,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:00:39,441 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,442 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:39,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,442 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:39,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,444 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,444 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,444 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,445 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:39,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:39,447 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:00:52,131 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,131 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:52,131 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,131 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,132 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:00:52,132 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,133 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,134 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,134 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,134 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:00:52,134 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:00:52,136 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:01:04,840 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,840 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,840 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:01:04,840 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:01:04,841 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,841 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,841 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,841 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:01:04,841 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:04,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:01:17,639 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,639 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:01:17,639 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,641 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,642 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,643 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:01:17,643 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,645 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,645 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,645 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:01:17,645 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:01:17,647 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:03:28,928 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,929 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:28,929 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,929 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,929 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:28,930 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,931 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,931 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,933 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,933 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:28,933 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:28,936 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:03:45,293 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,294 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:45,294 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,296 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,296 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:45,296 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,296 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,297 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,297 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:45,297 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,299 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:45,300 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:03:59,912 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,913 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:59,913 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,913 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,914 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:59,914 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,918 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,919 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:03:59,919 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:03:59,922 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 229,333 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 229,333 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 186,894 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 186,894 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 249 ‚Üí 224 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 235,035 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 235,035 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 159,024 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 159,024 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 197,400 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 197,400 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 105,341 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)2025-11-06 16:04:16,096 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:04:16,096 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:04:16,096 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:04:16,099 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:04:36,186 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:04:36,186 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:04:36,186 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:04:36,189 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:04:53,576 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:04:53,577 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:04:53,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:04:53,579 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:05:10,135 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:10,135 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:05:10,135 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:10,138 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:05:26,438 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:26,439 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:05:26,439 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:26,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

üèá Field mean earnings per race: 105,341 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 187,236 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 187,236 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[28%] Processing chunk 3/17 (Mem: 364MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 16:05:49,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,874 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:05:49,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,875 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,876 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:05:49,876 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,877 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,878 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,880 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,880 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:05:49,881 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:05:49,883 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:06:12,031 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,032 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,032 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:12,032 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:12,032 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,032 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,034 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,035 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,044 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,045 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:12,045 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:12,047 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:06:28,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,226 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:28,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,228 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,230 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:28,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,235 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,236 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:28,236 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:28,239 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:06:41,520 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,520 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:41,520 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,523 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,532 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,532 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:41,532 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,535 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:06:41,541 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,542 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:41,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:41,545 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:06:55,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,216 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:55,216 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,217 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:55,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,219 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,221 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:06:55,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:06:55,224 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:07:10,771 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,771 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:10,771 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,772 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,773 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:10,773 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,774 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,775 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,777 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,777 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:10,777 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:10,780 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:07:30,583 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,585 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:30,585 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,587 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,590 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,590 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,590 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:30,590 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,590 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:30,590 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,593 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:30,593 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:07:43,935 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,936 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:43,936 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,938 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,944 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,944 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:43,944 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,945 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,945 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:43,945 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,947 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:43,948 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:07:57,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,231 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:57,231 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,234 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,234 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:57,234 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,237 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,240 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,241 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:07:57,241 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:07:57,243 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:08:10,255 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,255 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:10,255 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,258 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,258 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,258 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:10,258 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,261 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,262 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,263 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:10,263 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:10,265 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:08:23,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,169 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:23,169 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,172 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,176 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,177 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:23,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,178 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,178 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:23,178 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,180 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:23,181 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:08:36,085 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,086 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:36,086 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,086 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,086 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:36,086 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,087 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,087 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:36,087 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,089 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,089 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:36,090 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:08:49,697 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,698 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:49,698 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,701 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,701 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,701 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:49,701 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,701 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,702 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:08:49,702 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,704 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:08:49,705 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:09:02,252 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,253 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:02,253 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,255 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,255 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:02,255 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,255 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,256 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,257 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:02,257 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,257 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:02,259 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:09:14,604 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,605 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:14,605 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,608 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,612 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,612 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:14,612 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,615 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,615 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,615 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:14,616 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:14,618 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 174,614 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 174,614 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 202,030 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 202,030 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 98,448 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 98,448 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 226,729 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 226,729 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 175,714 (from 10 horses)
  üìä Processing 10 horses for feature calculation...2025-11-06 16:09:26,825 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:26,825 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:26,825 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:26,827 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:09:38,180 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:38,181 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:38,181 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:38,183 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:09:52,441 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:52,442 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:09:52,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:09:52,444 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:10:12,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:12,826 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:10:12,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:12,829 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:10:29,240 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:29,240 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:10:29,240 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:29,242 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 175,714 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 4 horses)
  üìä Processing 4 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 4 horses)
  üìä Processing 4 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 135,270 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 135,270 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 198,059 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 198,059 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[33%] Processing chunk 4/17 (Mem: 357MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 16:10:53,630 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,630 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:10:53,630 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,632 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,632 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:10:53,632 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,633 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,634 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,634 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:10:53,634 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,635 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:10:53,637 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:11:15,840 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,840 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:15,840 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,843 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:15,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,844 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,845 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:15,845 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,846 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:15,847 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:11:30,790 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,790 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:30,791 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,791 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,791 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:30,791 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,793 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,794 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,797 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,797 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:30,797 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:30,800 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:11:44,270 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,271 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:44,271 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,273 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,274 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,274 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:44,274 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,274 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,275 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:44,275 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,277 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:44,277 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:11:57,715 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,716 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:57,716 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,718 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,718 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,719 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:57,719 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,722 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,722 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:11:57,722 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:11:57,725 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:12:11,849 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,850 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:12:11,850 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,852 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,856 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,856 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:12:11,856 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,862 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,863 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:12:11,863 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:12:11,865 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:14:27,517 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,518 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:27,518 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,518 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,518 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:27,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,520 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,521 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,523 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,523 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:27,523 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:27,526 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:14:43,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,520 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:43,520 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,522 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,526 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,527 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:43,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,528 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:43,528 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,530 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:43,530 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:14:56,855 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,855 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,856 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:56,856 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:56,856 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,856 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,859 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,860 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,860 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:14:56,860 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:14:56,863 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:15:10,187 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,187 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:10,187 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,189 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,191 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,191 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:10,191 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,193 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,194 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:10,194 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,194 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:10,196 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:15:24,018 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,019 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:24,019 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,021 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,026 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,026 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:24,026 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,028 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,030 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,030 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:24,030 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:24,033 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:15:38,656 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,657 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:15:38,657 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,658 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,658 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:38,658 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,659 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,660 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,662 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,662 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:38,662 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:38,664 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:15:51,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:15:51,344 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:15:51,344 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:15:51,345 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:51,348 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:51,348 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:51,348 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:51,350 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:15:51,361 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:51,361 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:15:51,361 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:15:51,363 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:16:04,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,215 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:04,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,221 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:04,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,222 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,222 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:04,222 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,223 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:04,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:16:17,401 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:17,402 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,404 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,404 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:17,405 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 92,546 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 92,546 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 176,626 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 176,626 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 138,911 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 138,911 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 87,242 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 87,242 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 185,357 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 185,357 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 255,507 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 255,507 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 107,889 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 107,889 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 211,403 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 211,403 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 231,393 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 231,393 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 226,098 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 226,098 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 108,712 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 108,712 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 249 ‚Üí 224 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 84,320 (from 10 horses)
  üìä Processing 10 horses for feature calculation...2025-11-06 16:16:34,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:34,167 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:34,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:34,170 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:16:46,650 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:46,652 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:46,652 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:46,654 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:16:59,052 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:59,052 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:16:59,052 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:16:59,055 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:17:11,707 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:11,707 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:17:11,708 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:11,709 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:17:24,436 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:24,436 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:17:24,436 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:24,438 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
[37%] Processing chunk 5/17 (Mem: 360MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 16:17:44,512 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,512 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:17:44,512 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,513 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:17:44,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,514 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,514 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:17:44,514 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,514 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,515 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:17:44,517 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:18:05,644 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,645 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:05,645 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,646 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,647 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:05,647 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,647 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,649 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,649 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,649 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:05,650 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:05,652 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:18:19,353 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,353 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:19,353 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,355 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,356 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,356 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:19,356 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,358 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,360 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,360 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:19,360 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:19,362 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:18:34,022 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,023 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:34,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,027 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,028 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:34,028 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,031 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,031 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,031 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:34,031 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:34,033 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:18:57,148 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,149 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:57,149 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,152 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,154 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,155 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:57,155 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,157 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,158 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,158 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:18:57,158 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:18:57,161 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:19:12,404 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,404 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:12,404 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,406 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,410 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,410 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 16:19:12,410 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:19:12,420 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:12,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:12,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:19:26,008 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,008 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:26,008 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,010 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,010 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,011 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:26,011 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,013 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,022 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:26,022 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:26,022 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:19:26,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:19:38,906 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,906 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:38,906 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,906 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,907 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:38,907 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,908 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,909 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,909 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,909 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:38,909 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:38,911 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:19:52,369 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,370 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:52,370 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,371 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,371 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:52,371 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,372 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,373 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,381 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,381 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:19:52,382 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:19:52,384 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:20:06,650 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,650 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:06,650 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,650 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,651 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:06,651 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,652 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,652 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,656 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,657 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:06,657 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:06,659 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:20:19,325 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,326 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:19,326 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,329 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,330 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,331 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:19,331 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,334 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,337 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,337 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:19,338 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:19,341 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:20:31,960 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,961 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:31,961 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,963 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,963 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:31,963 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,963 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,965 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:31,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:31,968 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:20:44,521 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,522 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:44,522 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,524 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,526 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,526 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:44,526 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,528 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,535 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,535 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:44,535 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:44,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:20:58,097 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 16:20:58,097 - core.orchestrators.feature_selector - INFO - Dropped 103 features for rf model
2025-11-06 16:20:58,097 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 16:20:58,100 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 16:20:58,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:58,104 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:58,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:58,107 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:58,109 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:58,109 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:20:58,110 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:20:58,112 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:27:41,598 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:41,599 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:27:41,599 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:41,601 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:41,603 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:41,604 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:27:41,604 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:41,606 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:27:41,620 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:41,620 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:27:41,620 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 16:27:41,624 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 4 horses)
  üìä Processing 4 horses for feature calculation...
Feature cleanup: 249 ‚Üí 224 (25 removed)
üèá Field mean earnings per race: 100,000 (from 4 horses)
  üìä Processing 4 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 4 horses)
  üìä Processing 4 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 4 horses)
  üìä Processing 4 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)2025-11-06 16:27:55,645 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:55,645 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:27:55,645 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:27:55,648 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:28:08,312 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:28:08,312 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:28:08,312 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:28:08,315 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:28:25,954 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:28:25,954 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:28:25,954 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:28:25,957 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:28:39,024 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:28:39,024 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:28:39,024 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:28:39,026 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:35:51,619 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:35:51,619 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:35:51,619 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:35:51,622 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[42%] Processing chunk 6/17 (Mem: 359MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:36:13,032 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,033 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:36:13,033 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,035 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,043 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,043 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:36:13,043 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,044 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,044 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:36:13,044 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,046 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:13,047 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:36:35,689 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,689 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:36:35,689 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,692 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,693 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,693 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:36:35,693 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,694 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,694 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:36:35,694 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,696 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:36:35,697 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:40:14,306 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,306 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:14,306 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,307 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,308 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:14,308 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,309 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,309 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,310 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:14,310 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,311 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:14,312 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:40:27,656 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,656 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:27,656 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,657 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,657 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:27,657 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,659 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,660 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,660 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,660 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:27,660 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:27,663 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 16:40:40,929 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,930 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:40,930 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,932 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,932 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,932 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:40,932 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,934 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,934 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 16:40:40,934 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,935 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 16:40:40,937 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:02:57,170 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,170 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:02:57,170 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,173 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,187 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,188 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:02:57,188 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:02:57,189 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,190 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:02:57,190 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,191 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:02:57,193 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:03:21,926 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,927 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:21,927 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,928 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,929 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:21,929 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,930 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,932 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,932 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,932 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:21,932 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:21,935 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:03:37,076 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,076 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:37,076 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,078 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,088 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,088 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:37,088 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,088 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,089 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:37,089 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,091 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:37,091 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:03:51,473 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,474 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:51,474 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,476 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,490 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:03:51,490 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:51,490 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,491 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,492 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:03:51,492 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,493 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:03:51,495 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:04:05,504 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,505 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:05,505 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,508 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,510 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,510 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:05,510 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,517 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,518 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:05,518 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:05,521 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:04:21,562 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,562 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:21,562 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,564 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,574 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,574 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:21,574 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,577 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:21,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:21,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:04:21,579 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:04:34,678 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,678 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:34,678 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,680 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,682 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,682 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:34,682 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,684 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,685 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,685 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:34,685 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:34,688 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:04:48,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,442 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:48,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:04:48,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,448 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:04:48,449 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:05:04,103 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,104 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:04,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,106 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,116 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,116 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:04,116 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,119 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:05:04,125 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,125 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:04,125 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:04,129 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:05:26,573 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,573 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,574 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:26,574 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:26,574 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,574 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,575 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,575 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:26,575 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:26,578 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...2025-11-06 17:05:49,170 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:49,171 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:05:49,171 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:05:49,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:06:16,279 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:06:16,280 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:06:16,280 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:06:16,285 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:06:41,764 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:06:41,765 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:06:41,765 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:06:41,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:07:01,184 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:01,184 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:07:01,184 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:01,187 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:07:18,707 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:18,707 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:07:18,707 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:18,709 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 232,572 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 232,572 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 252,883 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 252,883 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[46%] Processing chunk 7/17 (Mem: 359MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:07:43,953 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,953 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:07:43,953 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,956 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,959 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,959 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,959 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:07:43,959 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,959 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:07:43,959 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,962 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:07:43,962 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:08:08,900 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,901 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:08,901 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,904 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,909 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,910 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:08,910 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,912 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,913 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,913 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:08,913 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:08,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:26,570 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,572 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,573 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:26,573 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:08:40,382 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,383 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:40,383 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,385 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,389 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,389 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:40,389 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,391 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,391 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:40,391 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,392 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:40,394 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:08:56,565 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,566 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:56,566 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,569 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,576 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,577 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:56,577 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,579 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,580 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:08:56,581 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:08:56,581 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:08:56,584 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:09:09,784 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,785 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:09,785 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,787 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,790 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,791 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:09,791 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,793 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,793 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,794 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:09,794 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:09,796 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:09:23,635 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,636 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:23,636 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,637 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,637 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:23,637 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,639 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,639 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,639 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:23,639 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,640 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:23,644 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:09:46,687 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,688 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:46,688 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,689 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,689 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:46,689 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,690 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,692 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,697 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,698 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:09:46,698 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:09:46,701 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:10:04,764 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,765 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:04,765 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,767 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,771 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,771 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:04,771 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,774 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,777 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,778 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:04,778 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:04,781 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:10:22,578 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,579 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:22,579 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,581 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,584 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,585 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:22,585 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,587 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,589 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,589 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:22,589 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:22,591 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:10:40,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,167 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:40,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,170 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,172 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,173 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:40,173 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,175 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,177 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:40,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:40,180 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:10:54,051 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 17:10:54,052 - core.orchestrators.feature_selector - INFO - Dropped 103 features for rf model
2025-11-06 17:10:54,052 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 17:10:54,053 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:54,054 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:54,054 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:54,054 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 17:10:54,056 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:54,057 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:54,057 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:10:54,058 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:10:54,060 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:11:09,416 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,416 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:09,416 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,418 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,420 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:09,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,423 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:09,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:09,425 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:11:23,801 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,801 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:23,801 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,803 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,803 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:23,803 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,803 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,805 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,816 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:23,817 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:23,817 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:11:23,820 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:11:37,075 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,076 - core.orchestrators.feature_selector - INFO - Dropped 110 features for rf model
2025-11-06 17:11:37,076 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,078 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,079 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,079 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:37,079 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,081 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,081 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:37,081 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,082 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:37,084 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 241 ‚Üí 217 (24 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 194,392 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 194,392 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 169,275 (from 4 horses)
  üìä Processing 4 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 169,275 (from 4 horses)
  üìä Processing 4 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 250 ‚Üí 225 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 116,800 (from 16 horses)
  üìä Processing 16 horses for feature calculation...2025-11-06 17:11:51,788 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:51,788 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:11:51,788 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:11:51,791 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:12:04,792 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:04,793 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:12:04,793 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:04,795 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:12:20,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:20,412 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:12:20,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:20,415 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:12:36,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:36,365 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:12:36,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:36,368 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:12:52,808 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:52,808 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:12:52,808 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:12:52,811 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 116,800 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 190,396 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 190,396 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 182,267 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 182,267 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[50%] Processing chunk 8/17 (Mem: 349MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:13:25,652 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,652 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:13:25,652 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,655 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,659 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,659 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:13:25,659 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,662 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,666 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:25,666 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:13:25,666 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:13:25,669 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:13:48,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,215 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:13:48,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,216 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,217 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:13:48,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,217 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:13:48,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,218 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:13:48,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:14:14,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,423 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:14,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,425 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,426 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:14,426 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,426 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,428 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,429 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:14,429 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,429 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:14,432 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:14:39,414 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,415 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:39,415 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,417 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,417 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:39,417 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,418 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,421 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,421 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:39,421 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:39,425 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:14:55,224 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,224 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:55,224 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,227 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,232 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,232 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:55,232 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,235 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,236 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,237 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:14:55,237 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:14:55,240 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:15:40,145 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,145 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:15:40,145 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,147 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,151 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,151 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:15:40,151 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,154 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:15:40,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,168 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:15:40,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:40,171 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:15:55,131 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,131 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:15:55,131 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,132 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,132 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:15:55,132 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,134 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,135 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,136 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,137 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:15:55,137 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:15:55,140 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:16:10,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,769 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:16:10,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,769 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:16:10,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,771 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,772 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,774 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,774 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:16:10,774 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:16:10,777 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
/Users/mattg0/Docs/HorseAIv2/core/calculators/static_feature_calculator.py:1252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  result_df.at[index, key] = value
2025-11-06 17:23:37,493 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,493 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:23:37,493 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,493 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,494 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:23:37,494 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,496 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,496 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,498 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,499 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:23:37,499 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:37,502 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:23:53,507 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,508 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:23:53,508 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,508 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,508 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:23:53,508 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,508 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,509 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:23:53,509 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,511 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,512 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:23:53,512 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:24:09,024 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,024 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:24:09,024 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,025 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:24:09,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,026 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:24:09,026 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,027 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,027 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:09,028 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:24:52,744 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,745 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:24:52,745 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,747 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,748 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:24:52,748 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,748 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,750 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,751 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:24:52,751 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,751 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:24:52,754 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:25:15,533 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,534 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:25:15,534 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,536 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,541 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,542 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:25:15,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,543 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,544 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:25:15,544 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,545 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:25:15,547 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:33:19,149 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,150 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:19,150 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,150 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,150 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:19,150 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,152 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,152 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,162 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,162 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:19,162 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:19,165 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:33:34,443 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,444 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:34,444 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,446 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,448 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,448 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:34,449 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,452 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,458 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,458 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:34,458 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:34,461 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 200,992 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 200,992 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 213,464 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 213,464 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 214,268 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 214,268 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 215,722 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 215,722 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 257,100 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 257,100 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 161,581 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 161,581 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 183,289 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 183,289 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 153,256 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 153,256 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 170,914 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 170,914 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 238,883 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 238,883 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 179,969 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 179,969 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 198,875 (from 12 horses)
  üìä Processing 12 horses for feature calculation...2025-11-06 17:33:48,752 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:48,752 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:33:48,752 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:33:48,755 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:34:01,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:34:01,827 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:34:01,827 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:34:01,829 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:34:15,249 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:34:15,249 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:34:15,249 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:34:15,251 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:34:28,268 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:34:28,269 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:34:28,269 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:34:28,271 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:48:55,448 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:48:55,449 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:48:55,449 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:48:55,451 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[55%] Processing chunk 9/17 (Mem: 345MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 17:49:37,050 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,051 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:49:37,051 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,053 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,056 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,056 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:49:37,056 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,057 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,058 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:49:37,058 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,059 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:37,061 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:49:59,315 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,316 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:49:59,316 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,318 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,320 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,320 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:49:59,320 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,323 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:49:59,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:49:59,326 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:50:14,085 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,086 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:50:14,086 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,088 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,095 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,096 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:50:14,096 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,098 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,102 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:50:14,102 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:50:14,102 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:50:14,105 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:52:16,354 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,354 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:16,354 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,356 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,359 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,359 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:16,359 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,362 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,364 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:16,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:16,366 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:52:31,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,858 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:31,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,861 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,868 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,868 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:31,869 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,871 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,871 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:31,871 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,871 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:31,875 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 17:52:45,406 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,407 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:45,407 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,409 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,412 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:45,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,413 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 17:52:45,413 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,415 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 17:52:45,416 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:03:09,003 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,003 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,004 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:09,004 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:09,004 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,004 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,006 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,007 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,009 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,010 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:09,010 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:09,013 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:03:30,809 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,810 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:30,810 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,812 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,826 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:30,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,827 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,827 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:30,827 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:30,829 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:03:30,830 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:03:44,876 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,877 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:44,877 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,879 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,883 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,883 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:44,883 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,885 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,889 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,889 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:03:44,889 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:03:44,892 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:23:36,405 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,407 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:23:36,407 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,409 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,409 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:23:36,409 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,410 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,418 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,418 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:23:36,418 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:36,422 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:23:57,264 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,265 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:23:57,265 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,267 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,269 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,269 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:23:57,269 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,271 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,273 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,273 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:23:57,273 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:23:57,275 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:24:11,191 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,191 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:24:11,191 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,193 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,194 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:24:11,194 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,194 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,197 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,201 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,202 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:24:11,202 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:24:11,205 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:25:02,568 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,572 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:02,572 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,571 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,573 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,574 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:02,574 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,574 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:02,574 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,579 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,580 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:02,580 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:25:29,933 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,934 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:29,934 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,937 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,937 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:29,937 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,937 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,940 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,947 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,947 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:29,947 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:29,950 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:25:53,103 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,103 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:53,103 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,104 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:53,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,106 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,106 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,106 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:25:53,106 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,107 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:25:53,109 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 208,943 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 208,943 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 251,625 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 251,625 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 129,198 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 129,198 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 87,800 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 87,800 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 120,902 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 120,902 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 136,760 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 136,760 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 192,812 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 192,812 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 145,008 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 145,008 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 188,996 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 188,996 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 161,284 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 161,284 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 122,365 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 122,365 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 127,162 (from 16 horses)
  üìä Processing 16 horses for feature calculation...2025-11-06 18:26:07,199 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:07,200 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:26:07,200 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:07,203 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:26:22,371 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:22,372 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:26:22,372 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:22,374 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:26:38,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:38,365 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:26:38,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:38,367 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:26:53,803 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:53,803 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:26:53,804 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:26:53,806 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:27:10,409 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:10,410 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:27:10,410 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:10,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[59%] Processing chunk 10/17 (Mem: 346MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 18:27:49,536 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,537 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:27:49,537 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:27:49,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,538 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:27:49,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,540 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,540 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:27:49,541 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:28:12,710 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,710 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,710 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:28:12,710 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,710 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:28:12,710 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,711 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,711 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:28:12,711 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,713 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,713 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:28:12,714 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:34:15,591 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,591 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 18:34:15,591 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,593 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,594 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,594 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:15,594 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,596 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,600 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,601 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:15,601 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:15,603 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:34:38,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,413 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:38,413 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,415 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,418 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,419 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:38,419 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,421 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:38,421 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,422 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:38,423 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:34:52,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,513 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:52,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,515 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,519 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:52,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,522 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:34:52,531 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,531 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:34:52,531 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:34:52,534 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:40:21,283 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,284 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:21,284 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,287 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,294 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,294 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:21,294 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,297 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,300 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:21,301 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:21,301 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:40:21,305 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:40:41,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,023 - core.orchestrators.feature_selector - INFO - Dropped 110 features for rf model
2025-11-06 18:40:41,023 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,025 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,036 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,037 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:41,037 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:40:41,039 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,042 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,042 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:41,042 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:41,045 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:40:56,032 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,034 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:56,034 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,037 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,037 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,038 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:56,038 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,038 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,039 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:40:56,039 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,041 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:40:56,042 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:41:13,270 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,270 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:13,270 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,272 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,272 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:13,272 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,273 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,274 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,282 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,282 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:13,282 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:13,284 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:41:28,957 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,957 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:28,958 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,960 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,960 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,960 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:28,960 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,963 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,971 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,972 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:28,972 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:28,975 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:41:44,781 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,782 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:44,782 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,785 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,787 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,787 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:44,787 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,789 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,789 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:41:44,789 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,790 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:41:44,792 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:42:01,720 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,721 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:01,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,724 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,727 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,727 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:01,727 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,728 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,728 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:01,729 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,730 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:01,731 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:42:17,914 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,915 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:17,915 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,916 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:17,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,916 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:17,916 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,917 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,919 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:17,919 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:42:32,213 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,214 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:32,214 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,217 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,217 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:32,218 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,221 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:32,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:32,224 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:42:47,011 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,014 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:47,014 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,015 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,015 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,016 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:47,016 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,016 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:42:47,016 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,016 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,019 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:42:47,019 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 204,055 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 204,055 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 136,969 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 136,969 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 128,899 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 128,899 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 232,012 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 232,012 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 132,833 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 132,833 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 186,153 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 186,153 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 108,269 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 108,269 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 146,820 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 146,820 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 145,062 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 145,062 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 132,479 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 132,479 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 165,556 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 165,556 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...2025-11-06 18:43:01,096 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:01,096 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:43:01,096 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:01,099 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:43:21,065 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:21,066 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:43:21,066 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:21,069 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:43:38,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:38,167 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:43:38,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:38,170 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:43:55,081 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:55,081 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:43:55,081 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:43:55,084 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:44:14,903 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:14,904 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:44:14,904 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:14,907 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 17 horses)
  üìä Processing 17 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 17 horses)
  üìä Processing 17 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[64%] Processing chunk 11/17 (Mem: 348MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 18:44:39,604 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,604 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,604 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:44:39,604 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,604 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:44:39,604 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,606 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,606 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:44:39,606 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,607 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,607 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:44:39,609 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:45:02,685 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,686 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:02,686 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,687 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,687 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:02,687 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,688 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,688 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:02,688 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,689 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,690 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:02,691 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:45:19,893 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,893 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:19,893 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,894 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,894 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:19,894 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,896 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,897 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,897 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,898 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:19,898 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:19,901 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:45:33,761 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,762 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:33,762 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,764 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,766 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,766 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:33,766 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,769 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:33,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:33,772 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:45:48,850 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,851 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:48,851 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,851 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,852 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:48,852 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,854 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,854 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,856 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,856 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:45:48,856 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:45:48,859 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:46:05,962 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,963 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:05,963 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:05,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,967 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:05,968 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:46:19,620 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,621 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:19,621 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,623 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,623 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,623 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:19,623 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,625 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,633 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,634 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:19,634 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:19,636 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:46:33,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,225 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:33,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,226 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:33,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,227 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,228 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,230 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:33,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:33,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:46:48,815 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,815 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:48,815 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,817 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,823 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,823 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:48,823 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,825 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,826 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,827 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:46:48,827 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:46:48,829 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:47:04,036 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,037 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:04,037 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,038 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,038 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:04,038 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,039 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,040 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:47:04,054 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,054 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:04,054 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:04,057 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:47:17,271 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,271 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:17,271 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,273 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,281 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,281 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:17,281 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,283 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,283 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,284 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:17,284 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:17,286 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:47:30,360 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,360 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:30,360 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,362 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,365 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:30,365 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,366 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,366 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:30,366 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,367 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:30,368 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:47:44,747 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,748 - core.orchestrators.feature_selector - INFO - Dropped 110 features for rf model
2025-11-06 18:47:44,748 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,749 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,749 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:44,749 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,750 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,751 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,751 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,752 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:47:44,752 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:47:44,753 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:48:11,615 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,616 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:48:11,616 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,617 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,618 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:48:11,618 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,619 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,620 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,623 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,624 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:48:11,624 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:11,627 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:48:38,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,226 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:48:38,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,228 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,228 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:48:38,228 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,229 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,231 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:48:38,231 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:48:38,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 3 horses)
  üìä Processing 3 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 3 horses)
  üìä Processing 3 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)2025-11-06 18:49:04,399 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:49:04,400 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:49:04,400 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:49:04,403 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:49:24,183 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:49:24,183 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:49:24,183 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:49:24,185 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:49:45,617 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:49:45,617 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:49:45,617 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:49:45,619 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:50:10,904 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:50:10,905 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:50:10,905 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:50:10,908 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:50:32,563 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:50:32,564 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:50:32,564 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:50:32,566 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 6 horses)
  üìä Processing 6 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[68%] Processing chunk 12/17 (Mem: 354MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 18:51:05,414 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,414 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:51:05,414 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,416 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,417 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,417 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:51:05,417 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,420 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,427 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,427 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:51:05,427 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:51:05,431 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:53:14,511 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,512 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,513 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:53:14,513 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:53:14,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,513 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,518 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:53:14,560 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,561 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:53:14,561 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:14,566 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:53:48,314 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,315 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:53:48,315 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,319 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,323 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:53:48,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,327 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:53:48,359 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,360 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:53:48,360 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:53:48,364 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:54:16,488 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,489 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:54:16,489 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,492 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,495 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,495 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:54:16,495 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,498 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,498 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,498 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:54:16,498 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:16,501 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:54:45,838 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,839 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:54:45,839 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,839 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,840 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:54:45,840 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,844 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:54:45,844 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:54:45,847 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:55:10,368 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,369 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:10,369 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,372 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,376 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,376 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:10,376 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,378 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,379 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,380 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:10,380 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:10,382 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:55:35,943 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,944 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:35,944 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,946 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,947 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,948 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:35,948 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,951 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,952 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,952 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:35,953 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:35,955 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:55:57,610 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,611 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:57,611 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,613 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,614 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,614 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:57,614 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,617 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,617 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,617 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:55:57,617 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:55:57,620 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:56:17,838 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,838 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 18:56:17,838 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,841 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:56:17,857 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,858 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:17,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,861 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,864 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,866 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:17,866 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:17,870 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:56:42,012 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,013 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:42,013 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,014 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,015 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:42,015 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,015 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,017 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,031 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:42,032 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:56:42,032 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:56:42,036 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:56:56,680 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,681 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:56,681 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,680 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,681 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:56,681 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,685 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,685 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,692 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,693 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:56:56,693 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:56:56,696 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:57:13,463 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,464 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:13,464 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,466 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,471 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,471 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,471 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:13,472 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,472 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:13,472 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,475 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:13,475 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:57:29,212 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,212 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:29,212 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,214 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,215 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:29,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,215 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,218 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,221 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:29,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:29,224 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:57:45,035 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,036 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:45,036 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,038 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,040 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,040 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:45,040 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,042 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,042 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:45,042 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,043 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:45,045 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:57:59,275 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,276 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:59,276 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,279 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,283 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,283 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:59,283 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,285 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,285 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:57:59,285 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,286 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:57:59,288 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 148,157 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 148,157 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 226,429 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 226,429 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 17 horses)
  üìä Processing 17 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 17 horses)
  üìä Processing 17 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...2025-11-06 18:58:17,356 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:58:17,356 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:58:17,356 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:58:17,358 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:58:32,014 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:58:32,014 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:58:32,014 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:58:32,017 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:58:46,098 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:58:46,098 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:58:46,099 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:58:46,100 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:59:00,161 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:00,162 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:59:00,162 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:00,165 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 18:59:14,726 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:14,727 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:59:14,727 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:14,729 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)

Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
[72%] Processing chunk 13/17 (Mem: 350MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 18:59:44,306 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,306 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,307 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:59:44,307 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,307 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:59:44,307 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,307 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,308 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 18:59:44,308 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,310 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,310 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 18:59:44,311 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:00:11,286 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,287 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:11,287 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,287 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,287 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:11,287 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,290 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,291 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,291 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,292 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:11,292 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:11,295 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:00:35,803 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,804 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:35,804 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,807 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,807 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,807 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,807 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:35,807 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,808 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:35,808 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,810 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:35,811 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:00:51,598 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,598 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,599 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:51,599 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,599 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:51,599 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,601 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,601 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,603 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,603 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:00:51,603 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:00:51,606 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:01:05,735 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,735 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:05,735 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,738 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,740 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,740 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:05,740 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,743 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,744 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,744 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:05,744 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:05,747 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:01:19,777 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,778 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:19,778 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,781 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,781 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,781 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:19,781 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,783 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,783 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:19,783 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,784 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:19,786 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:01:43,286 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,287 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:43,287 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,291 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,291 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,292 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:43,292 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,295 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,298 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,298 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:01:43,298 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:01:43,301 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:02:01,161 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,161 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:01,161 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,161 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,162 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:01,162 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,164 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,164 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,164 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,164 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:01,164 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:01,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:02:15,161 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,162 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:15,162 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,164 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,164 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:15,164 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,165 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,168 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:15,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:15,171 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:02:31,473 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,473 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:31,473 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,477 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,479 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,479 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:31,479 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,483 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,483 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,484 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:31,484 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:31,487 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:02:54,534 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,535 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:54,535 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,542 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:54,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,545 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,549 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,549 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:02:54,549 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:02:54,553 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:03:10,969 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,970 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:10,970 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,973 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,974 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,975 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:10,975 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,977 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,981 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,982 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:10,982 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:10,984 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:03:25,174 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,175 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:25,175 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,178 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,181 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,182 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:25,182 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,182 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,182 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:25,183 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,185 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:25,186 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:03:42,357 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,357 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:42,357 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,358 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,358 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:42,358 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,359 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,359 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:03:42,359 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,360 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,362 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:03:42,363 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:04:04,657 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,658 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:04:04,658 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,661 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,661 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,661 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:04:04,661 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,665 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,670 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,670 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:04:04,670 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:04,675 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...2025-11-06 19:04:21,133 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:21,134 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:04:21,134 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:21,136 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:04:36,248 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:36,249 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:04:36,249 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:36,252 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:04:50,406 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:50,406 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:04:50,406 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:04:50,409 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:05:05,135 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:05,136 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:05:05,136 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:05,138 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:05:19,641 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:19,641 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:05:19,641 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:19,644 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[77%] Processing chunk 14/17 (Mem: 352MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 19:05:44,845 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,846 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:05:44,846 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,846 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,846 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:05:44,846 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,849 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,849 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,849 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,849 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:05:44,849 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:05:44,853 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:06:09,172 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,173 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:06:09,173 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,174 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,174 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,174 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:06:09,174 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,174 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:06:09,174 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,176 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,178 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:09,178 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:06:28,867 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,868 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:06:28,868 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,870 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,872 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,872 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:06:28,872 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,874 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:06:28,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,875 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:06:28,877 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:08:44,872 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,872 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,872 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,874 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:08:44,874 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:08:44,874 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:08:44,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,879 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,879 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:08:44,879 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:09:01,622 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,623 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:01,623 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,625 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,625 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:01,625 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,626 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,627 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,627 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:01,627 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,628 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:01,631 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:09:18,832 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,832 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:18,833 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,835 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,835 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,836 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:18,836 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,838 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,843 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:18,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:18,846 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:09:35,730 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,732 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:35,732 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,734 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,740 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,740 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:35,740 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,741 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,742 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:35,742 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,743 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:35,745 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:09:55,800 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,800 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:55,800 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,801 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,801 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:55,801 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,803 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,804 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,805 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,806 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:09:55,806 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:09:55,808 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:10:13,176 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,177 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:13,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,179 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,179 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:13,179 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,180 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,180 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,180 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:13,180 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,182 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:13,183 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:10:35,875 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,876 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:35,876 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,878 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,881 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,881 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:35,881 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,884 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,890 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,891 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:35,891 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:35,894 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:10:58,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:58,542 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:58,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:58,544 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:58,545 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:58,546 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 19:10:58,546 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:58,548 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:10:58,559 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:10:58,559 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:10:58,559 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:10:58,562 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:11:15,021 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,021 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,022 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:11:15,022 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,022 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:11:15,022 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,024 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,024 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,035 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,036 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:11:15,036 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:11:15,039 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:15:06,281 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,282 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:06,282 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,284 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,290 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,290 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:06,290 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,293 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,295 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,295 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:06,295 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:06,298 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:15:31,196 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,197 - core.orchestrators.feature_selector - INFO - Dropped 110 features for rf model
2025-11-06 19:15:31,197 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,199 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,200 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,200 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:31,201 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,203 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,204 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,204 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:31,204 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:31,207 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:15:46,309 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,310 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 19:15:46,310 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,313 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,323 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:46,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,324 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,324 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:15:46,324 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,327 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:15:46,327 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 235,591 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 235,591 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 131,342 (from 14 horses)
  üìä Processing 14 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 131,342 (from 14 horses)
  üìä Processing 14 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 135,523 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 135,523 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 199,953 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 199,953 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 250 ‚Üí 225 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 249 ‚Üí 224 (25 removed)
üèá Field mean earnings per race: 100,000 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...2025-11-06 19:18:41,674 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:18:41,675 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:18:41,675 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:18:41,677 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:18:57,878 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:18:57,879 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:18:57,879 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:18:57,881 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:21:13,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:21:13,320 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:21:13,320 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:21:13,323 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:21:38,209 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:21:38,210 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:21:38,210 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:21:38,213 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:22:00,720 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:00,721 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:00,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:00,724 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[81%] Processing chunk 15/17 (Mem: 352MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 19:22:26,078 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,078 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:26,078 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,079 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,079 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:26,079 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,081 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,081 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,082 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:26,082 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,082 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:26,085 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:22:49,797 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,798 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:49,798 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,800 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,800 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:49,800 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,801 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,801 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,802 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:22:49,802 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,804 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:22:49,805 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:25:15,747 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,748 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:15,748 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,748 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,748 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:15,749 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,751 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,751 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,755 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,755 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:15,755 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:15,759 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:25:36,922 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,923 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,923 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:36,923 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:36,923 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,923 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,927 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,927 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,927 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,945 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:36,949 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:36,952 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:25:53,220 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,221 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:53,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,221 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:53,221 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,222 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,222 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:25:53,223 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,224 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:25:53,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:26:09,167 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,168 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:09,168 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,171 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,177 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:09,177 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,181 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,181 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,181 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:09,182 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:09,185 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:26:24,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,843 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:24,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,845 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,850 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,851 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:24,851 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,854 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,854 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,855 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:24,855 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:24,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:26:43,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,722 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:43,722 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,725 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,729 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,730 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:43,730 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,733 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,734 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,735 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:26:43,735 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:26:43,738 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:27:00,334 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,335 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:00,335 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,338 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,343 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:00,343 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,344 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,345 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:00,345 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,346 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:00,348 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:27:14,434 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,434 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:14,434 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,437 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,439 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,439 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:14,439 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,442 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,444 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,445 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:14,445 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:14,448 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:27:29,809 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,809 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:29,809 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,812 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,817 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,817 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:29,817 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,821 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,821 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,821 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:29,821 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:29,824 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:27:46,663 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,664 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:46,664 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,667 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,674 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,675 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:46,675 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,677 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,677 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:27:46,677 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,678 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:27:46,681 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:28:01,527 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,528 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:01,528 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,531 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,536 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,537 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:01,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,537 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:01,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,540 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:01,540 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:28:15,533 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,533 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:15,533 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,536 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,537 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,538 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:15,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,538 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:15,538 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,541 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:15,542 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:28:32,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,225 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:32,225 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,226 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:32,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,228 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,229 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,229 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,230 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:32,230 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:32,233 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 18 horses)
  üìä Processing 18 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 144,879 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 144,879 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 238,081 (from 7 horses)
  üìä Processing 7 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 238,081 (from 7 horses)
  üìä Processing 7 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 173,346 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 173,346 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 122,168 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 122,168 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 130,651 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 130,651 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 194,358 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 194,358 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 100,000 (from 10 horses)
  üìä Processing 10 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 207,834 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 207,834 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 192,257 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 192,257 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 253,571 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 253,571 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 177,604 (from 11 horses)
  üìä Processing 11 horses for feature calculation...2025-11-06 19:28:53,284 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:53,285 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:28:53,285 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:28:53,287 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:29:07,766 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:07,767 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:29:07,767 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:07,769 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:29:21,857 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:21,857 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:29:21,857 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:21,860 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:29:41,165 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:41,165 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:29:41,165 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:41,169 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:29:57,033 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:57,034 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:29:57,034 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:29:57,036 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[86%] Processing chunk 16/17 (Mem: 354MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 19:30:21,045 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,045 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:30:21,045 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,046 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,046 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:30:21,046 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,048 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,049 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,050 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,050 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:30:21,050 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:30:21,054 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:35:05,858 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,859 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:05,859 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,861 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,861 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:05,861 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,862 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,864 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,867 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,867 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:05,867 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:05,870 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:35:23,834 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 19:35:23,835 - core.orchestrators.feature_selector - INFO - Dropped 103 features for rf model
2025-11-06 19:35:23,835 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 19:35:23,838 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 19:35:23,839 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:23,839 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:23,839 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:23,840 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:23,841 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:23,841 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:23,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:23,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:35:38,904 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 19:35:38,904 - core.orchestrators.feature_selector - INFO - Dropped 103 features for rf model
2025-11-06 19:35:38,904 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 19:35:38,906 - core.orchestrators.feature_selector - INFO - RF features: 113 domain features (no embeddings)
2025-11-06 19:35:38,910 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:38,911 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:38,911 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:38,912 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:38,912 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:38,912 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:38,913 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:38,915 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:35:58,934 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,935 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,935 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:58,935 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,935 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:58,935 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,938 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,938 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,939 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,939 - core.orchestrators.feature_selector - INFO - Dropped 111 features for rf model
2025-11-06 19:35:58,939 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:35:58,942 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:36:19,272 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,273 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:19,273 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,275 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,280 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,281 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:19,281 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,283 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,289 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:19,289 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:19,289 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:36:19,292 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:36:33,098 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,099 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:33,099 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,101 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,105 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:33,105 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,107 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,111 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,112 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:33,112 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:33,115 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:36:48,839 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,839 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:48,839 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,842 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:48,842 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,843 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,844 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,845 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:36:48,845 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,845 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:36:48,848 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:51:16,474 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,474 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,476 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,477 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:51:16,477 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:51:16,477 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:51:16,477 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,477 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,477 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,481 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,482 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:16,482 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:51:43,375 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,376 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:51:43,376 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,379 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,379 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,379 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:51:43,380 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,381 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,381 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:51:43,381 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,382 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:51:43,385 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:52:08,515 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,515 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:08,515 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,518 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,519 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:08,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,519 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,522 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,529 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,529 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:08,529 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:08,532 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:52:25,927 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,927 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:25,927 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,928 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,929 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:25,929 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,930 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,931 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,940 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,940 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:25,940 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:25,943 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:52:41,088 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,089 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:41,089 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,091 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,095 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,095 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:41,096 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,098 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,101 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,101 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:52:41,101 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:52:41,104 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:53:03,210 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,210 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,210 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:03,210 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,211 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:03,211 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,213 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,213 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,222 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,223 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:03,223 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:03,226 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:53:20,463 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,464 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:20,464 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,466 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,467 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,467 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:20,467 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,469 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,480 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:20,480 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:20,480 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:53:20,483 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
‚úì Loaded 21 selected features from models/2025-11-02/2years_061730/feature_selector.json
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 157,610 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 157,610 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 245,877 (from 16 horses)
  üìä Processing 16 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 245,877 (from 16 horses)
  üìä Processing 16 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 241 ‚Üí 217 (24 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 241 ‚Üí 217 (24 removed)
üèá Field mean earnings per race: 100,000 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 219,529 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 251 ‚Üí 226 (25 removed)
üèá Field mean earnings per race: 219,529 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 100,000 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 235,583 (from 8 horses)
  üìä Processing 8 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 235,583 (from 8 horses)
  üìä Processing 8 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 171,083 (from 15 horses)
  üìä Processing 15 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 171,083 (from 15 horses)
  üìä Processing 15 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 100,000 (from 12 horses)
  üìä Processing 12 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 100,000 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 164,778 (from 11 horses)
  üìä Processing 11 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 164,778 (from 11 horses)
  üìä Processing 11 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 100,000 (from 13 horses)
  üìä Processing 13 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 144,243 (from 9 horses)
  üìä Processing 9 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 144,243 (from 9 horses)
  üìä Processing 9 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...
Feature cleanup: 253 ‚Üí 228 (25 removed)
üèá Field mean earnings per race: 100,000 (from 5 horses)
  üìä Processing 5 horses for feature calculation...

Calibration loaded from: models/calibration/general_calibration.json
  Version: 2025-11-06T15:55:56.917429
  Corrections: 6
  üîÑ Using temporal calculations (no data leakage mode)
  ‚úÖ Preserving existing career stats from database (prediction mode)
üèá Field mean earnings per race: 147,122 (from 9 horses)
  üìä Processing 9 horses for feature calculation...2025-11-06 19:53:34,720 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:34,721 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:34,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:34,723 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:53:47,602 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:47,603 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:53:47,603 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:53:47,606 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:54:02,244 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:02,245 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:54:02,245 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:02,247 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:54:16,099 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:16,099 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:54:16,099 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:16,101 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:54:29,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:29,874 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:54:29,874 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:29,877 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[90%] Processing chunk 17/17 (Mem: 357MB)...
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/pytorch_tabnet/abstract_model.py:82: UserWarning: Device used : cpu
  warnings.warn(f"Device used : {self.device}")
2025-11-06 19:54:51,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,412 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:54:51,412 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,413 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,413 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:54:51,413 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,413 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,413 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:54:51,413 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,415 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,416 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:54:51,416 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:55:14,964 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,965 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:14,965 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,967 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,973 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,973 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:14,973 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,974 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,975 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:14,975 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,976 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:14,978 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:55:30,773 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,774 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:30,774 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,776 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,785 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,785 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:30,785 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,788 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,790 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:30,790 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:30,790 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:55:30,793 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:55:44,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,721 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:44,721 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,723 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,731 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,732 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:44,732 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,734 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,735 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,735 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:55:44,735 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:55:44,738 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:56:03,313 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,314 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:03,314 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,316 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,316 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:03,316 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,316 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,319 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,321 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,322 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:03,322 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:03,324 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:56:17,756 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,756 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:17,756 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,759 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,759 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,759 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:17,759 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,762 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,762 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,762 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:17,763 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:17,765 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:56:34,887 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:34,888 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:34,888 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:34,890 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:34,893 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:34,893 - core.orchestrators.feature_selector - INFO - Dropped 113 features for rf model
2025-11-06 19:56:34,893 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:34,896 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
2025-11-06 19:56:52,291 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:52,292 - core.orchestrators.feature_selector - INFO - Dropped 109 features for rf model
2025-11-06 19:56:52,292 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
2025-11-06 19:56:52,295 - core.orchestrators.feature_selector - INFO - RF features: 114 domain features (no embeddings)
/Users/mattg0/miniconda3/envs/HorseAIv2/lib/python3.11/site-packages/sklearn/ensemble/_base.py:168: UserWarning: Loky-backed parallel loops cannot be called in a multiprocessing, setting n_jobs=1
  n_jobs = min(effective_n_jobs(n_jobs), n_estimators)
[95%] Storing predictions to database...
[100%] Complete! Processed 821 races in 15012.4s

============================================================
‚úÖ BATCH PREDICTION COMPLETE
============================================================
  Job ID: batch_20251106_154652
  Total races: 821
  Successful: 821
  Failed: 0
  Total time: 15012.54s
  Throughput: 0.1 races/second
============================================================
